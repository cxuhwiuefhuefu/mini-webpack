<!--
 * @Author: Sunny
 * @Date: 2022-11-08 00:10:23
 * @LastEditors: Suuny
 * @LastEditTime: 2022-11-14 20:46:04
 * @Description: 
 * @FilePath: /mini-webpack/readme.md
-->
import 由 esm 模块化规范决定的





任务拆分的思想

(数据) --> 图（graph） --> Text（脚本）

- 基于文件的内容 构建生成图
- 基于图生成对应的脚本


构建一张图需要获取什么呢？
- 1. 文件内容
- 2. 依赖关系


为什么是图关系结构？
因为 mian.js 和 foo.js 会存在循环引用的结构



package.json 添加 "type": "module" 支持 esm 模块


如何获取依赖关系？
- 正则表达式
- AST  （通过 babel 进行处理）


用队列去遍历图
广度优先搜索



esm规范告诉我们 import 只能在顶层作用域里面

非js 模块化思想 -> Commonjs 模块化规范



生成当前的文件的方案
- 字符串拼接
- 模版生成器去生成 ejs


命名重复的问题
- 给每个模块每个唯一的ID，到时候基于ID 进行查找
- 映射关系


用到 ast
- 涉及到编译原理 
- JS 基础知识





------------------------------------------------------------------------------------------------> 




babel 只认识 js 不认识 json 所以报错   需要 用到 json
引入 loader 把非 js 文件转化为 js 文件  再次执行




推荐看英文文档
中文文档不更新及时
```js
import { getOptions } from 'loader-util'

const options = getOptions(this); // 被废弃掉
```


webpack loader 会把 loader 





------------------------------------------------------------------------------------------------> 



插件的实现原理是基于事件的架构去实现的 
webpack 在不同的阶段会发出不同的事件来
由插件编写者去监听对应的编写事件 然后拿到它给我们暴露出来的对象
然后通过操作对象上的方法来去改变我们打包的行为 这个就是它的实现原理


其实最核心的原理是事件机制 这个事件机制我们用 webpack 去实现就行了
因为webpack 在底层去实现事件的库  Tapable

我们去学习插件的时候其实就是去理解整个 webpack 的打包过程
发出对应的事件我们去监听 


最核心的两个点
先注册 后触发

插件的功能允许我们改变打包之后的路径 就是打包路径的时候给他发出一个事件


之前实现 loader 是暴露 api 供我们调用


compiler 在不同的阶段监听不同的事件